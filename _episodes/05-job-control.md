---
title: 作业控制
teaching: 5
exercises: 0
questions:
- "如何跟踪在我的机器上运行的进程？"
- "我可以在一个 shell 中运行多个程序/脚本吗？"
objectives:
- "了解如何使用 `ps` 获取有关进程状态的信息" 
- "了解如何控制，即“停止/暂停/后台/前台”进程"
keypoints:
- "当我们谈论“作业控制”时，我们真正的意思是“进程控制”"
- "可以停止、暂停和/或使正在运行的进程在后台运行"
- "可以启动一个进程以便立即在后台运行"
- "可以将暂停或后台进程带回前台"
- "进程信息可以用`ps`检查"
---

Shell小白入门课解释了我们如何在shell的命令行运行程序或脚本。

*一旦它们正在运行*，我们现在来看看如何控制程序。

当我们谈论控制程序时，我们真正的意思是控制*进程*。正如我们之前所说，一个进程只是一个程序那是在内存中并正在执行。 您计算机上的一些进程
是你的：他们正在运行你明确要求的程序，比如你的网页浏览器。

## `ps` 命令

您可以使用 `ps` 命令列出进程，就像使用 `ls`列出文件和目录。

> ## `ps` 命令的行为
>
> `ps` 命令有一系列选项标志来控制
> 它的行为，更重要的是，参数和默认
> 行为因平台而异。
>
> 对 `ps` 的简单调用仅向您显示有关的基本信息
> *你的*，*活动的*进程。
>
> 之后，这是一个值得一读的命令
> '`man` page' for.
>
{: .callout}

~~~
$ ps
~~~
{: .bash}
~~~
  PID TTY          TIME CMD
12767 pts/0    00:00:00 bash
15283 pts/0    00:00:00 ps
~~~
{: .output}

在你运行`ps`命令的时候，你有
两个活动进程，您的 (`bash`) shell 和 (`ps`) 命令
你已经在其中调用了。

很有可能您已经知道该信息，而无需运行一个命令来告诉你，所以让我们试着加更多的信息。
~~~
$ ps -f
~~~
{: .bash}
~~~
UID        PID  PPID  C STIME TTY          TIME CMD
vlad     12396 25397  0 14:28 pts/0    00:00:00 ps -f
vlad     25397 25396  0 12:49 pts/0    00:01:39 bash
~~~
{: .output}

如果您还没有时间执行“man ps”，请注意
`-f` 标志不代表“骨头上的肉”，而是代表
“做全格式上市”，虽然即便如此，也有“更全”
`ps` 输出的版本。

但是我们在这里被告知了什么？

每个进程都有一个唯一的进程 ID (PID)。请记住，这是一个
进程的属性，而不是进程正在执行的程序的属性：
如果您同时运行三个浏览器实例，每个实例都会
有自己的进程ID。

此清单中的第三列 PPID 显示每个进程的 ID
父母。计算机上的每个进程都是由另一个进程产生的，这是它的
父级（当然，除了运行的引导进程
计算机启动时自动）。

显然，运行的 `ps -f` 是 (`bash`) 的子进程
调用它的 shell。

第 1 列显示用户的用户名进程
正在运行。这是计算机在检查时使用的用户名
权限：每个进程都被允许访问完全相同的东西
运行它的用户，不多也不少。

第 5 列，STIME，显示进程开始运行的时间，而第 7 列，
TIME，显示进程使用了​​多少时间，而第 8 列，
CMD，显示进程正在执行的程序。

第 6 列，TTY，显示
运行此进程的终端的 ID。曾几何时，
这真的是一个连接到中央分时度假的终端
计算机。现在它已经不那么重要了，除非一个过程是
系统服务，例如网络监视器，`ps` 将显示
其终端的问号，因为它实际上没有一个。

第四列 C 表示处理器的百分比
利用率。

您的 `ps` 版本可能
显示更多或更少的列，或者可能以不同的顺序显示它们，但是
相同的信息通常随处可见，并且该列
标题通常是一致的。

## 停止、暂停、恢复和后台处理进程

shell 提供了几个用于停止、暂停和恢复的命令
过程。 要查看它们的实际效果，让我们在我们的
最新的数据文件。 几分钟后，我们意识到这是
需要一段时间才能完成。 不耐烦，我们通过
键入 Control-C。 这会立即停止当前执行的程序。
它计算出来但未写入磁盘的任何结果都将丢失。

~~~
$ ./analyze results*.dat
~~~
{: .bash}

~~~
...a few minutes pass...
^C
~~~
{: .output}

让我们再次运行相同的命令，并在末尾添加一个 & 符号
告诉 shell 我们希望它在后台运行。

~~~
$ ./analyze results*.dat &
~~~
{: .bash}

当我们这样做时，shell 会像以前一样启动程序。 代替
让我们的键盘和屏幕连接到程序的标准
但是，输入和输出，shell 挂在它们上面。 这意味着
shell 可以给我们一个全新的命令提示符，并开始运行其他
命令，马上。 例如，我们在这里放置一些参数
用于文件中程序的下一次运行：

~~~
$ cat > params.txt
density: 22.0
viscosity: 0.75
^D
~~~
{: .bash}

（记住，\^D 是 shell 显示 Control-D 的方式，意思是“结束
输入”。）现在让我们运行 `jobs` 命令，它告诉我们什么
进程当前在后台运行：

~~~
$ jobs
~~~
{: .bash}

~~~
[1] ./analyze results01.dat results02.dat results03.dat
~~~
{: .output}

既然我们要去喝咖啡，我们不妨使用
前台命令，`fg`，将我们的后台作业带入
前台：

~~~
$ fg
~~~
{: .bash}

~~~
...a few minutes pass...
~~~
{: .output}

当 `analyze` 完成运行时，shell 会给我们一个新的提示：
通常。 如果我们在后台运行多个作业，我们可以
使用 `fg %1`、`fg %2` 控制我们将哪一个带到前台，
等等。 ID 不是*进程 ID。 相反，他们是作业
`jobs` 命令显示的 ID。

shell 为我们提供了另一个作业控制工具：如果一个进程是
已经在前台运行，Control-Z 将暂停并返回
控制到shell。 然后我们可以使用`fg`来恢复它
前台，或 `bg` 将其恢复为后台作业。 例如，让我们
再次运行“分析”，然后键入 Control-Z。 shell立即
告诉我们我们的程序已经停止，并给我们它的作业编号：

~~~
$ ./analyze results01.dat
^Z
~~~
{: .bash}

~~~
[1]  Stopped   ./analyze results01.dat
~~~
{: .output}

如果我们键入 `bg %1`，shell 会再次启动进程运行，但在
背景。 我们可以使用`jobs`检查它是否正在运行，然后杀死它
虽然它仍然在后台使用`kill`和作业号。 这
与将其置于前台然后键入相同的效果
控制-C：

~~~
$ bg %1

$ jobs
~~~
{: .bash}
~~~
[1] ./analyze results01.dat
~~~
{: .output}
~~~
$ kill %1
~~~
{: .bash}

当用户只有一个终端窗口时，作业控制很重要
时间。 现在它不那么重要了：如果我们想运行另一个程序，它是
很容易打开另一个窗口并在那里运行它。 然而，这些
想法和工具正在卷土重来，因为它们通常是最简单的方法
在其他地方的远程计算机上运行和控制程序
网络。 本课的 [ssh episode]({{ page.root }}/02-ssh/{{ site.index }}) 有更多
说一下。

{% include links.md %}
