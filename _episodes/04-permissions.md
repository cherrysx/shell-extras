---
title: "权限控制"
teaching: 10
exercises: 0
questions:
- "文件目录的权限是什么？"
- "怎么样查看权限？"
- "怎么样改变权限？"
objectives:
- "理解文件和目录的权限"
- "改变文件目录的权限"
keypoints:
- "正确的权限对于系统的安全性至关重要。" 
- "文件权限描述了可以读取、写入、修改和访问文件的人员和对象。"
- "使用 `ls -l` 查看特定文件的权限。" 
- "使用 `chmod` 更改文件或目录的权限。"
---

Linux 使用 *permissions* 控制谁可以读取、修改和运行文件。
我们将在本节末尾讨论 Windows 如何处理权限：
概念相似，
但规则不同。

让我们从内尔开始。
她有一个唯一的 [用户名]({{ page.root }}/reference/{{ site.index }}#user-name)，
`nnemo`,
和 [用户 ID]({{ page.root }}/reference/{{ site.index }}#user-id)，
1404.

> ## 为什么是整数ID？
>
> 为什么使用整数作为ID？
> 同样，答案可以追溯到197 年代初期。
> 像 `alan.turing` 这样的字符串长度不同，
> 相互比较需要很多说明。
> 整数，
> 另一方面，
> 使用相当少量的存储空间（通常是四个字符），
> 并且可以与单个指令进行比较。
> 为了使操作快速简单，
> 程序员经常使用整数在内部跟踪事物，
> 然后使用某种查找表
> 将这些整数转换为用户友好的文本以进行演示。
> 当然，
> 程序员就是程序员，
> 他们经常会跳过用户友好的字符串部分
> 并且只使用整数。
{: .callout}

用户可以属于任意数量的[组]({{ page.root }}/reference/{{ site.index }}#user-group)，
每个都有一个唯一的 [组名]({{ page.root }}/reference/{{ site.index }}#user-group-name)
和数字 [组 ID]({{ page.root }}/reference/{{ site.index }}#user-group-id)。
属于哪个组的人员列表通常存储在文件“/etc/group”中。
（如果你现在在一台 Unix 机器前，
尝试运行 `cat /etc/group` 来查看该文件。）

现在让我们看看文件和目录。
Unix 计算机上的每个文件和目录都属于一个所有者和一个组。
随着每个文件的内容，
操作系统存储拥有它的用户和组的数字 ID。

用户和组模型意味着
对于每个文件
系统上的每个用户都属于以下三类之一：
文件的所有者，
文件组中的某个人，
和其他所有人。

对于这三个类别中的每一个，
计算机跟踪
该类别的人是否可以阅读该文件，
写入文件，
或执行文件
（即，如果它是一个程序，则运行它）。

例如，如果文件具有以下权限集：

<table class="table table-striped">
<tr><td></td><th>用户</th><th>组</th><th>所有</th></tr>
<tr><th>读</th><td>yes</td><td>yes</td><td>no</td></tr>
<tr><th>写</th><td>yes</td><td>no</td><td>no</td></tr>
<tr><th>执行</th><td>no</td><td>no</td><td>no</td></tr>
</table>

这意味着：

* 文件的所有者可以读写，但不能运行；
* 文件所在组的其他人可以读取，但不能修改或运行； 和
* 其他人对此根本无能为力。

让我们看看这个模型的实际应用。
如果我们 `cd` 进入 `labs` 目录并运行 `ls -F`，
它在 `setup` 的名称末尾放置一个 `*`。
这是它告诉我们 `setup` 是可执行的方式，
IE。，
它（可能）是计算机可以运行的东西。

~~~
$ cd labs
$ ls -F
~~~
{: .bash}
~~~
safety.txt    setup*     waiver.txt
~~~
{: .output}

> ## 必要但不充分
>
> 某些东西被标记为可执行的事实
> 实际上并不意味着它包含某种程序。
> 我们可以轻松地将这个 HTML 文件标记为可执行文件
> 使用下面介绍的命令。
> 根据我们使用的操作系统，
> 试图“运行”它要么失败
>（因为它不包含计算机识别的指令）
> 或导致操作系统打开文件
> 使用通常处理它的任何应用程序
>（例如网络浏览器）。
{: .callout}

现在让我们运行命令“ls -l”：

~~~
$ ls -l
~~~
{: .bash}
~~~
-rw-rw-r-- 1 vlad bio  1158  2010-07-11 08:22 safety.txt
-rwxr-xr-x 1 vlad bio 31988  2010-07-23 20:04 setup
-rw-rw-r-- 1 vlad bio  2312  2010-07-11 08:23 waiver.txt
~~~
{: .output}

`-l` 标志告诉 `ls` 给我们一个长列表。
信息量很大，让我们依次浏览各栏目。

在右侧，我们有文件的名称。
在他们身边，
向左移动，
是它们最后一次修改的时间和日期。
备份系统和其他工具以多种方式使用这些信息，
但你可以用它来告诉你什么时候（或其他任何人）
最后更改了一个文件。

修改时间旁边是文件的大小（以字节为单位）
以及拥有它的用户和组的名称
（在这种情况下，分别是 `vlad` 和 `bio`）。
我们现在将跳过第二列
（每个文件显示“1”的那个）
因为这是我们最关心的第一列。
这显示了文件的权限，即谁可以读取、写入或执行它。

让我们仔细看看其中一个权限字符串：
`-rwxr-xr-x`。
第一个字符告诉我们这是什么类型的东西：
'-' 表示它是一个常规文件，
而 'd' 表示它是一个目录，
和其他字符意味着更深奥的东西。

接下来的三个字符告诉我们文件所有者拥有什么权限。
在这里，所有者可以读取、写入和执行文件：`rwx`。
中间的三元组向我们展示了该组的权限。
如果权限被关闭，我们会看到一个破折号，所以 `r-x` 表示“读取和执行，但不写入”。
最后一个三元组向我们展示了不是文件所有者或文件组中的每个人都可以做什么。
在这种情况下，它又是“r-x”，所以系统上的每个人都可以查看文件的内容并运行它。

要更改权限，我们使用 `chmod` 命令
（其名称代表“更改模式”）。
这是一个长列表，显示了最终成绩的权限
在弗拉德教授的课程中：

~~~
$ ls -l final.grd
~~~
{: .bash}

~~~
-rwxrwxrwx 1 vlad bio  4215  2010-08-29 22:30 final.grd
~~~
{: .output}

哎呀：世界上每个人都可以阅读它——更糟糕的是，
修改它！
（他们也可以尝试将成绩文件作为程序运行，
这几乎肯定行不通。）

将所有者权限更改为 `rw-` 的命令是：

~~~
$ chmod u=rw final.grd
~~~
{: .bash}

'u' 表示我们正在更改权限
用户的（即文件的所有者），
并且 `rw` 是新的权限集。
一个快速的 `ls -l` 告诉我们它有效，
因为所有者的权限现在设置为读写：

~~~
$ ls -l final.grd
~~~
{: .bash}

~~~
-rw-rwxrwx 1 vlad bio  4215  2010-08-30 08:19 final.grd
~~~
{: .output}

让我们再次运行 `chmod` 以授予组只读权限：

~~~
$ chmod g=r final.grd
$ ls -l final.grd
~~~
{: .bash}

~~~
-rw-r--rw- 1 vlad bio  4215  2010-08-30 08:19 final.grd
~~~
{: .output}

最后，
让我们给“所有”（系统上不是文件所有者或不在其组中的每个人）根本没有权限：

~~~
$ chmod a= final.grd
$ ls -l final.grd
~~~
{: .bash}

~~~
-rw-r----- 1 vlad bio  4215  2010-08-30 08:20 final.grd
~~~
{: .output}

这里，
'a' 表示我们正在更改“all”的权限，
由于“=”的右侧没有任何内容，
“all”的新权限为空。

我们也可以按权限搜索。
在这里，例如，我们可以使用 `-type f -perm -u=x` 来查找文件
用户可以执行：
~~~
$ find . -type f -perm -u=x
~~~
{: .bash}

~~~
./tools/format
./tools/stats
~~~
{: .output}

在我们走得更远之前，
让我们运行`ls -a -l`
获取包含通常隐藏的目录条目的长列表：
~~~
$ ls -a -l
~~~
{: .bash}

~~~
drwxr-xr-x 1 vlad bio     0  2010-08-14 09:55 .
drwxr-xr-x 1 vlad bio  8192  2010-08-27 23:11 ..
-rw-rw-r-- 1 vlad bio  1158  2010-07-11 08:22 safety.txt
-rwxr-xr-x 1 vlad bio 31988  2010-07-23 20:04 setup
-rw-rw-r-- 1 vlad bio  2312  2010-07-11 08:23 waiver.txt
~~~
{: .output}

`.` 和 `..`（此目录及其父目录）的权限以“d”开头。
但看看他们的其余权限：
“x”表示“执行”已打开。
那是什么意思？
目录不是程序——我们如何“运行”它？

事实上，“x”对于目录来说意味着不同的东西。
它赋予某人*遍历*目录的权利，但不能查看其内容。
区别很微妙，所以让我们看一个例子。
Vlad 的主目录包含三个子目录，分别称为“venus”、“mars”和“pluto”：

![目录执行权限](../fig/x-for-directories.svg)

其中每一个都有一个子目录，依次称为“notes”，
这些子目录包含各种文件。
如果用户对 `venus` 的权限是 'r-x'，
那么如果她尝试使用 `ls` 查看 `venus` 和 `venus/notes` 的内容，
电脑让她看到两者。
如果她对 `mars` 的权限只是 'r--'，
然后允许她阅读`mars`和`mars/notes`的内容。
但如果她对 `pluto` 的权限只有 '--x'，
她看不到 `pluto` 目录中的内容：
`ls pluto` 会告诉她她没有查看其内容的权限。
但是，如果她试图查看“pluto/notes”，计算机会让她这样做。
她被允许通过“冥王星”，但不能看那里有什么。
这个技巧为人们提供了一种让他们的一些目录对整个世界可见的方法
没有打开其他一切。

## 窗户呢？

这些是 Unix 权限的基础知识。
但是，正如我们在一开始所说的那样，Windows 上的工作方式有所不同。
在那里，权限由 [访问控制列表]({{ page.root }}/reference/{{ site.index }}#access-control-list) 定义，
或 ACL。
ACL 是一个对的列表，每个对都结合了“谁”和“什么”。
例如，
您可以授予木乃伊将数据附加到文件的权限，而无需授予他读取或删除文件的权限，
并授予弗兰肯斯坦删除文件的权限，但无法查看其中包含的内容。

这比 Unix 模型更灵活，
但在小型系统上管理和理解也更加复杂。
（如果您有一个大型计算机系统，
*没有什么*易于管理或理解。）
一些现代的 Unix 变体支持 ACL 以及旧的读写执行权限，
但几乎没有人使用它们。
> ## 挑战
> 
> 如果 `ls -l myfile.php` 返回以下详细信息：
>
> ~~~
> -rwxr-xr-- 1 caro zoo  2312  2014-10-25 18:30 myfile.php
> ~~~
> {: .output}
> 
> 以下哪项陈述是正确的？
>
> 1. caro（所有者）可以读、写和执行myfile.php
> 2. caro（所有者）无法写入 myfile.php
> 3. caro（一个组）的成员可以读、写和执行myfile.php
> 4. zoo（组）成员不能执行myfile.php
{: .challenge}

{% include links.md %}
